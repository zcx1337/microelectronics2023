Здесь реализован поиск произведения нечетных элементов вектора

```
X"0000_0001", --start of vector
X"0000_0004",
X"0000_0009",
X"0000_0003",
X"0000_0002",
```

. Результат в регистре r3 (=27).


Код программы, которая это делает:

```
X"0700_0000",
X"1001_0004",
X"1004_0001",
X"1003_0001",    
X"3002_010A", 
X"0405_0204",
X"5009_0001",    
X"0203_0302",
X"1101_0101",    
X"5004_00FA", --end of prog
```

. Она вместе с вектором помещена в `variable mem :memory_array` в `memory.vhd`.

Она составлена с помощью таблицы:

| номер команды       | команда в 16-м виде                      | псевдокод                                        | пояснение                                                                  |   |
|---------------------|------------------------------------------|--------------------------------------------------|----------------------------------------------------------------------------|---|
| 0                   | 0700_0000                                | r0 = r0 & !r0                                    | r0 это вспомогательный ноль                                                |   |
| 1                   | 1001_0004                                | r1 = r0 + 4                                      | int i = 4; r1 - это i для цикла (4 потому, что вплоть до i=0, а не до i=1) |   |
| 2                   | 1004_0001                                | r4 = r0 + 1                                      | это единица для побитового умножения                                       |   |
| 3                   | 1003_0001                                | r3 = r0 + 1                                      | int mul = 1; r3 - это mul                                                  |   |
| 4: метка start_loop | 3002_01{v_address}                       | load quick r2 = M[r1 + v_address]                | тело цикла. берем v[i] в r2                                                |   |
| 5                   | 0405_0204                                | logical and r5 = r2 & r4 (r4 = 1)                | берем последний бит числа. Умножаем побитово с единицей                    |   |
| 6                   | 5009_00{end_loop-this=8-6=2 -> 1}        | branch quick, invz=1001, 00, смещение=main_loop  | если результат ноль, прыгаем на end_loop (пропускаем mul *= v[i])          |   |
| 7                   | 0203_0302                                | r3 = r3 * r2                                     | mul *= v[i];                                                               |   |
| 8: метка end_loop   | 1101_0101                                | r1 = r1 - 1                                      | выхода из цикла (две команды)                                              |   |
| 9                   | 5004_00{start_loop-this=4-9=-5=fb -> fa} | branch quick, invz=0100, 00, смещение=start_loop | если i >= 0, прыгаем на начало тела цикла                                  |   |

. fb и fa это отрицательные шеснадцатеричные числа для прыжка вверх по коду, записанные в дополнительном коде. Можно вычислить это так:

| ff | -1                     |
| fe | -2                     |
| fd | -3                     |
| fc | -4                     |
| fb | -5 (нужный нам отступ) |
| fa | -6 (с учетом PC++)     |

. 